//package org.example;
//
//class Main {
//    public static void main(String[] args) {
//        // * double d = 5.5; 의 처리과정
//        // 1 : 실수 5.5가 생긴다.
//        // 2 : 오직 실수만 담을 수 있는 변수 d가 생성된다.
//        // 3 : d는 5.5가 자신안에 들어 올 수 있는지 판단한다.(가능)
//        // 4 : d변수에 실수 5.5가 들어간다.
//        double d = 5.5;
//
//        // * double dd = 5; 의 처리과정
//        // 1 : 정수 5가 생긴다.
//        // 2 : 오직 실수만 담을 수 있는 변수 dd가 생성된다.
//        // 3 : dd는 5가 자신안에 들어 올 수 있는지 판단한다.
//        // 4 : 5는 정수이기 때문에 들어 올 수 없다고 판단한다.(불가능)
//        // 5 : dd가 아쉬워하는 5에게 이렇게 이야기 합니다. `니가 실수로 변환될 수 있다면 들어올 수 있다.`
//        // 6 : 5는 자신의 형태를 버리고 실수화 한다. 즉 5.0으로 변신하다.(캐스팅, 또는 형변환)
//        // 7 : dd로 5.0이 들어간다.
//        double dd = 5;
//
//        // * int i = 5.5; 의 처리과정
//        // 1 : 실수 5.5가 생긴다.
//        // 2 : 오직 정수만 담을 수 있는 변수 i가 생성된다.
//        // 3 : i는 5.5가 자신에게 담길 수 있는지 체크한다.(불가능)
//        // 4 : i는 아쉬워하는 5.5에게 이렇게 이야기 합니다. `니가 정수가 된다면 들어올 수 있다.`
//        // 5 : 5.5는 도저히 불가능 요구를 받고 치명적인 에러를 발생시킨다.(캐스팅 불가능 으로 인한 에러)
//        //int i = 5.5;
//
//// 문제 : `무기 a무기 = new 칼();` 가 실행되는 세부과정을 자세히 쓰세요.
//        무기 a무기 = new 칼();
//        // 1. 무기 타입의 리모컨을 가질 변수 a무기가 생성된다.
//        // 2. a무기에게 칼 타입의 리모컨이 들어가려고 하자 오류가 발생한다. 타입 미스매치
//        // 3. 칼 타입의 리모컨이 무기 타입의 리모컨으로 둔갑하기 위해 무기 클래스를 상속받는다. extends 무기
//        // 4. 문법 오류가 발생하지 않게 되었다.
//        // 5. 왜? : 칼 타입의 리모컨이 무기 타입의 리모컨의 형태로 둔갑하면 타입 미스매치가 발생하지 않기 때문이다.
//        // 6. a무기에 무기 타입으로 둔갑한 칼 타입의 리모컨이 들어간다. 이 과정에서 칼타입 고유의 필드 또는 메소드들은 버려진다.
//
//
//// 문제 : `매개변수`를 사용해서 전사가 매번 다르게 공격하도록 해주세요.
//        System.out.println("문제 : 매개변수를 사용해서 전사가 매번 다르게 공격하도록 해주세요.");
//        // 메소드 오버로딩
//        전사 a전사 = new 전사();
//
//        a전사.공격("브라이언", "칼");
//        // 브라이언이(가) 칼(으)로 공격합니다.
//
//        a전사.공격("필립", "창");
//        // 필립이(가) 창(으)로 공격합니다.
//
//        a전사.공격("마크", "지팡이");
//        // 마크(가) 지팡이(으)로 공격합니다.
//
//// 문제 : `매개변수`를 사용해서 전사가 매번 다르게 공격하도록 해주세요.
//        System.out.println("문제 : 매개변수를 사용해서 전사가 매번 다르게 공격하도록 해주세요.");
//        Warrior warrior = new Warrior();
//
//        warrior.공격("브라이언", "칼");
//        // 브라이언이(가) 칼(으)로 공격합니다.
//
//        warrior.재공격();
//        // 브라이언이(가) 칼(으)로 공격합니다.
//
//        warrior.공격("필립", "창");
//        // 필립이(가) 창(으)로 공격합니다.
//
//        warrior.공격("마크", "지팡이");
//        // 마크(가) 지팡이(으)로 공격합니다.
//
//        warrior.재공격();
//        // 마크(가) 지팡이(으)로 공격합니다.
//
//        warrior.재공격();
//        // 마크(가) 지팡이(으)로 공격합니다.
//
//        // 위 문제와 달리 문제 2 에서는 이전에 공격했던 전사가 사용했던 무기로 또 한번 공격하는 재공격 메소드가 추가되었다.
//        // 이 때 재공격에는 공격을 시행하는 공격자의 이름과 무기가 주어지지 않기 때문에(인자로 주어지는 값들이 없다.),
//        // 어딘가에는 이전에 공격했던 공격자의 이름과 무기의 정보가 저장이 되어야 한다. (인스턴스 변수 필요)
//        // 이를 위해서는 클래스 객체 내부에 공격자의 이름과 무기의 정보를 필드로 저장하고, 클래스 메소드로 필드에 접근하는 방식이 요구된다.
//    }
//}
//
//class 무기 { }
//
//class 칼 extends 무기 { }
//
//class 전사 {
//    void 공격(String attacker, String weapon) {
//        System.out.println(attacker + "이(가) " + weapon + "(으)로 공격합니다.");
//    }
//}
//
//class Warrior {
//    String attacker;
//    String weapon;
//
//    void 공격(String attacker, String weapon) {
//        this.attacker = attacker;
//        this.weapon = weapon;
//        System.out.println(this.attacker + "이(가) " + this.weapon + "(으)로 공격합니다.");
//    }
//
//    void 재공격() {
//        System.out.println(this.attacker + "이(가) " + this.weapon + "(으)로 공격합니다.");
//    }
//}